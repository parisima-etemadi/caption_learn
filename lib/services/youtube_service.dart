import 'dart:async';
import 'package:uuid/uuid.dart';
import 'package:youtube_explode_dart/youtube_explode_dart.dart';
import '../core/utils/logger.dart';
import '../core/utils/youtube_utils.dart';
import '../features/video/data/models/video_content.dart';
import '../features/video/domain/enum/video_source.dart';

class YouTubeService {
  static final YouTubeService _instance = YouTubeService._internal();
  final YoutubeExplode _youtubeExplode = YoutubeExplode();
  final Logger _logger = const Logger('YouTubeService');
  
  // Cache for video metadata to avoid repeated API calls
  final Map<String, Video> _videoCache = {};
  final Map<String, List<ClosedCaption>> _subtitleCache = {};
  
  factory YouTubeService() => _instance;
  YouTubeService._internal();

  /// Enhanced video processing with better error handling and caching
  Future<VideoContent> processVideoUrl(String url) async {
    if (!YoutubeUtils.isYoutubeUrl(url)) {
      throw YouTubeServiceException('Invalid YouTube URL format');
    }

    final videoId = YoutubeUtils.extractYoutubeVideoId(url);
    if (videoId == null || videoId.isEmpty) {
      throw YouTubeServiceException('Could not extract video ID from URL');
    }

    try {
      // Get video metadata (with caching)
      final video = await _getVideoWithCache(videoId);
      
      // Check if video is available
      if (!video.isLive && video.duration == null) {
        throw YouTubeServiceException('Video appears to be unavailable');
      }

      // Get subtitles (with caching)
      final subtitles = await _getSubtitlesWithCache(videoId);

      return VideoContent(
        id: _generateId(),
        title: video.title,
        sourceUrl: url,
        source: VideoSource.youtube,
        subtitles: subtitles,
        dateAdded: DateTime.now(),
      );
      
      // Additional metadata available but not stored in VideoContent:
      // - video.thumbnails.highResUrl (thumbnail URL)
      // - video.duration?.inMilliseconds (duration)
      // - video.author (channel name)
      // - video.engagement.viewCount (view count)
      // - video.uploadDate (upload date)
      // Access via: _getVideoWithCache(videoId) if needed
    } on VideoUnplayableException {
      throw YouTubeServiceException('Video is not playable (private, deleted, or region-blocked)');
    } on RequestLimitExceededException {
      throw YouTubeServiceException('YouTube request limit exceeded. Please try again later.');
    } catch (e) {
      _logger.e('Error processing YouTube video', e);
      throw YouTubeServiceException('Failed to process video: ${e.toString()}');
    }
  }

  /// Get video metadata with caching
  Future<Video> _getVideoWithCache(String videoId) async {
    // Check cache first
    if (_videoCache.containsKey(videoId)) {
      _logger.d('Using cached video metadata for: $videoId');
      return _videoCache[videoId]!;
    }

    // Fetch from YouTube with timeout
    final video = await _youtubeExplode.videos
        .get(videoId)
        .timeout(
          const Duration(seconds: 30),
          onTimeout: () => throw YouTubeServiceException('Video metadata request timed out'),
        );

    // Cache the result
    _videoCache[videoId] = video;
    _logger.i('Fetched and cached video metadata: ${video.title}');
    
    return video;
  }

  /// Get subtitles with caching and multiple language support
  Future<List<Subtitle>> _getSubtitlesWithCache(String videoId) async {
    // Check cache first
    if (_subtitleCache.containsKey(videoId)) {
      _logger.d('Using cached subtitles for: $videoId');
      return _convertToSubtitles(_subtitleCache[videoId]!);
    }

    final subtitles = <Subtitle>[];

    try {
      // Get closed captions manifest with timeout
      final manifest = await _youtubeExplode.videos.closedCaptions
          .getManifest(videoId)
          .timeout(
            const Duration(seconds: 30),
            onTimeout: () => throw YouTubeServiceException('Subtitle manifest request timed out'),
          );

      if (manifest.tracks.isEmpty) {
        _logger.i('No subtitle tracks available for video: $videoId');
        return subtitles;
      }

      // Find the best available track (prefer English, then auto-generated, then first available)
      final track = _selectBestSubtitleTrack(manifest.tracks);
      
      _logger.i('Selected subtitle track: ${track.language.name} (${track.isAutoGenerated ? 'auto-generated' : 'manual'})');

      // Get the actual captions with timeout
      final closedCaptions = await _youtubeExplode.videos.closedCaptions
          .get(track)
          .timeout(
            const Duration(seconds: 45),
            onTimeout: () => throw YouTubeServiceException('Subtitle download timed out'),
          );

      // Cache the raw captions
      _subtitleCache[videoId] = closedCaptions.captions;

      // Convert to app format
      return _convertToSubtitles(closedCaptions.captions);
      
    } catch (e) {
      if (e is YouTubeServiceException) rethrow;
      _logger.e('Error fetching YouTube subtitles for $videoId', e);
      // Don't throw here - videos without subtitles are still valid
      return subtitles;
    }
  }

  /// Select the best available subtitle track
  ClosedCaptionTrackInfo _selectBestSubtitleTrack(List<ClosedCaptionTrackInfo> tracks) {
    // Priority order:
    // 1. Manual English track
    // 2. Auto-generated English track  
    // 3. Any manual track
    // 4. Any auto-generated track

    // Try to find manual English track
    var track = tracks.where((t) => 
        t.language.code.toLowerCase() == 'en' && !t.isAutoGenerated
    ).firstOrNull;
    
    if (track != null) return track;

    // Try auto-generated English
    track = tracks.where((t) =>
        t.language.code.toLowerCase() == 'en' && t.isAutoGenerated
    ).firstOrNull;
    
    if (track != null) return track;

    // Try any manual track
    track = tracks.where((t) => !t.isAutoGenerated).firstOrNull;
    
    if (track != null) return track;

    // Fall back to first available
    return tracks.first;
  }

  /// Convert YouTube captions to app subtitle format
  List<Subtitle> _convertToSubtitles(List<ClosedCaption> captions) {
    return captions.map((caption) => Subtitle(
      startTime: caption.offset.inMilliseconds,
      endTime: (caption.offset + caption.duration).inMilliseconds,
      text: _cleanSubtitleText(caption.text),
    )).toList();
  }

  /// Clean subtitle text (remove extra formatting, normalize)
  String _cleanSubtitleText(String text) {
    return text
        .replaceAll(RegExp(r'<[^>]*>'), '') // Remove HTML tags
        .replaceAll(RegExp(r'\s+'), ' ')    // Normalize whitespace
        .trim();
  }

  /// Get video quality options
  Future<List<VideoStreamInfo>> getVideoStreams(String videoId) async {
    try {
      final manifest = await _youtubeExplode.videos.streamsClient.getManifest(videoId);
      return manifest.videoOnly.toList();
    } catch (e) {
      _logger.e('Error fetching video streams', e);
      return [];
    }
  }

  /// Check if video is available without full processing
  Future<bool> isVideoAvailable(String url) async {
    try {
      final videoId = YoutubeUtils.extractYoutubeVideoId(url);
      if (videoId == null) return false;
      
      final video = await _youtubeExplode.videos.get(videoId).timeout(
        const Duration(seconds: 10)
      );
      
      return video.duration != null; // Simple availability check
    } catch (e) {
      return false;
    }
  }

  /// Get channel information
  Future<Channel?> getChannelInfo(String channelId) async {
    try {
      return await _youtubeExplode.channels.get(channelId);
    } catch (e) {
      _logger.e('Error fetching channel info', e);
      return null;
    }
  }

  /// Clear all caches
  void clearCache() {
    _videoCache.clear();
    _subtitleCache.clear();
    _logger.i('Cleared YouTube service caches');
  }

  /// Clear old cache entries (call periodically)
  void cleanupCache({int maxEntries = 50}) {
    if (_videoCache.length > maxEntries) {
      final entries = _videoCache.entries.toList();
      _videoCache.clear();
      // Keep only the most recent entries
      _videoCache.addEntries(entries.take(maxEntries));
    }
    
    if (_subtitleCache.length > maxEntries) {
      final entries = _subtitleCache.entries.toList();
      _subtitleCache.clear();
      _subtitleCache.addEntries(entries.take(maxEntries));
    }
    
    _logger.i('Cleaned up YouTube service caches');
  }

  /// Generate unique ID
  String _generateId() {
    return const Uuid().v4();
  }

  /// Dispose resources
  void dispose() {
    _youtubeExplode.close();
    _videoCache.clear();
    _subtitleCache.clear();
    _logger.d('YouTube service disposed');
  }
}

/// Custom exception for YouTube service errors
class YouTubeServiceException implements Exception {
  final String message;
  
  const YouTubeServiceException(this.message);
  
  @override
  String toString() => 'YouTubeServiceException: $message';
}

/// Extension to add firstOrNull method
extension IterableExtension<T> on Iterable<T> {
  T? get firstOrNull {
    final iterator = this.iterator;
    if (iterator.moveNext()) {
      return iterator.current;
    }
    return null;
  }
}
