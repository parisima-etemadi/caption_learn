import 'dart:async';
import 'dart:math' as math;
import 'package:http/http.dart' as http;
import 'package:uuid/uuid.dart';
import 'package:youtube_explode_dart/youtube_explode_dart.dart';
import '../core/utils/logger.dart';
import '../core/utils/youtube_utils.dart';
import '../features/video/data/models/video_content.dart';
import '../features/video/domain/enum/video_source.dart';

class YouTubeService {
  static final YouTubeService _instance = YouTubeService._internal();
  final YoutubeExplode _youtubeExplode = YoutubeExplode();
  final Logger _logger = const Logger('YouTubeService');
  
  // Cache for video metadata to avoid repeated API calls
  final Map<String, Video> _videoCache = {};
  final Map<String, List<ClosedCaption>> _subtitleCache = {};
  
  factory YouTubeService() => _instance;
  YouTubeService._internal();

  /// Enhanced video processing with better error handling and caching
  Future<VideoContent> processVideoUrl(String url) async {
    if (!YoutubeUtils.isYoutubeUrl(url)) {
      throw YouTubeServiceException('Invalid YouTube URL format');
    }

    final videoId = YoutubeUtils.extractYoutubeVideoId(url);
    if (videoId == null || videoId.isEmpty) {
      throw YouTubeServiceException('Could not extract video ID from URL');
    }

    List<Subtitle> subtitles;
    String? subtitleWarning;

    try {
      // Get video metadata (with caching)
      final video = await _getVideoWithCache(videoId);
      
      // Check if video is available
      if (!video.isLive && video.duration == null) {
        throw YouTubeServiceException('Video appears to be unavailable');
      }

      // Get subtitles (with caching)
      try {
        subtitles = await _getSubtitlesWithCache(videoId);
      } on YouTubeSubtitleException catch (e) {
        _logger.w('Could not fetch subtitles for $videoId: ${e.message}');
        subtitles = [];
        subtitleWarning = e.message;
      }

      return VideoContent(
        id: _generateId(),
        title: video.title,
        sourceUrl: url,
        source: VideoSource.youtube,
        subtitles: subtitles,
        dateAdded: DateTime.now(),
        // This field needs to be added to the VideoContent model
        subtitleWarning: subtitleWarning,
      );
      
      // Additional metadata available but not stored in VideoContent:
      // - video.thumbnails.highResUrl (thumbnail URL)
      // - video.duration?.inMilliseconds (duration)
      // - video.author (channel name)
      // - video.engagement.viewCount (view count)
      // - video.uploadDate (upload date)
      // Access via: _getVideoWithCache(videoId) if needed
    } on VideoUnplayableException {
      throw YouTubeServiceException('Video is not playable (private, deleted, or region-blocked)');
    } on RequestLimitExceededException {
      throw YouTubeServiceException('YouTube request limit exceeded. Please try again later.');
    } catch (e) {
      _logger.e('Error processing YouTube video', e);
      throw YouTubeServiceException('Failed to process video: ${e.toString()}');
    }
  }

  /// Get video metadata with caching
  Future<Video> _getVideoWithCache(String videoId) async {
    // Check cache first
    if (_videoCache.containsKey(videoId)) {
      _logger.d('Using cached video metadata for: $videoId');
      return _videoCache[videoId]!;
    }

    // Fetch from YouTube with timeout
    final video = await _youtubeExplode.videos
        .get(videoId)
        .timeout(
          const Duration(seconds: 30),
          onTimeout: () => throw YouTubeServiceException('Video metadata request timed out'),
        );

    // Cache the result
    _videoCache[videoId] = video;
    _logger.i('Fetched and cached video metadata: ${video.title}');
    
    return video;
  }

  /// Get subtitles with caching and multiple language support
  Future<List<Subtitle>> _getSubtitlesWithCache(String videoId) async {
    // Check cache first
    if (_subtitleCache.containsKey(videoId)) {
      _logger.d('Using cached subtitles for: $videoId');
      return _convertToSubtitles(_subtitleCache[videoId]!);
    }

    final subtitles = <Subtitle>[];

    try {
      _logger.i('Attempting to fetch subtitles for video: $videoId');
      
      // Get closed captions manifest with timeout
      final manifest = await _youtubeExplode.videos.closedCaptions
          .getManifest(videoId)
          .timeout(
            const Duration(seconds: 60), // Increased timeout
            onTimeout: () => throw YouTubeServiceException('Subtitle manifest request timed out'),
          );

      if (manifest.tracks.isEmpty) {
        _logger.i('No subtitle tracks in manifest for video: $videoId');
        
        // Try alternative method: get transcript directly
        try {
          _logger.i('Attempting to fetch auto-generated transcript...');
          final transcript = await _fetchAutoGeneratedTranscript(videoId);
          if (transcript.isNotEmpty) {
            _logger.i('Successfully fetched auto-generated transcript');
            return transcript;
          }
        } catch (e) {
          _logger.e('Failed to fetch auto-generated transcript', e);
        }
        
        return subtitles;
      }

      _logger.i('Found ${manifest.tracks.length} subtitle tracks');
      for (var track in manifest.tracks) {
        _logger.d('Track: ${track.language.name} (${track.language.code}) - ${track.isAutoGenerated ? 'auto' : 'manual'}');
      }

      // Find the best available track (prefer English, then auto-generated, then first available)
      final track = _selectBestSubtitleTrack(manifest.tracks);
      
      _logger.i('Selected subtitle track: ${track.language.name} (${track.isAutoGenerated ? 'auto-generated' : 'manual'})');

      // Get the actual captions with timeout
      final closedCaptions = await _youtubeExplode.videos.closedCaptions
          .get(track)
          .timeout(
            const Duration(seconds: 90), // Increased timeout
            onTimeout: () => throw YouTubeServiceException('Subtitle download timed out'),
          );

      if (closedCaptions.captions.isEmpty) {
        _logger.w('No captions found in selected track');
        return subtitles;
      }

      _logger.i('Successfully fetched ${closedCaptions.captions.length} captions');

      // Cache the raw captions
      _subtitleCache[videoId] = closedCaptions.captions;

      // Convert to app format
      return _convertToSubtitles(closedCaptions.captions);
      
    } catch (e, stacktrace) {
      if (e is YouTubeServiceException) rethrow;
      _logger.e('Error fetching YouTube subtitles for $videoId: ${e.toString()}', e, stacktrace);
      
      // Try one more time with a different approach
      try {
        _logger.i('Attempting fallback subtitle fetch...');
        final fallbackSubtitles = await _fetchSubtitlesFallback(videoId);
        if (fallbackSubtitles.isNotEmpty) {
          _logger.i('Fallback subtitle fetch successful.');
          return fallbackSubtitles;
        }
      } catch (fallbackError) {
        _logger.e('Fallback subtitle fetch also failed', fallbackError);
      }
      
      // If both primary and fallback methods fail, throw a specific error.
      final errorString = e.toString().toLowerCase();
      String errorMessage = (errorString.contains('403') || errorString.contains('forbidden'))
          ? 'Subtitles unavailable: Access is restricted by YouTube for this video.'
          : 'Failed to download subtitles. They may be in an unsupported format.';

      throw YouTubeSubtitleException(errorMessage);
    }
  }

  /// Select the best available subtitle track
  ClosedCaptionTrackInfo _selectBestSubtitleTrack(List<ClosedCaptionTrackInfo> tracks) {
    // Priority order:
    // 1. Manual English track
    // 2. Auto-generated English track  
    // 3. Any manual track
    // 4. Any auto-generated track

    _logger.d('Selecting best subtitle track from ${tracks.length} available tracks');

    // Try to find manual English track
    var track = tracks.where((t) => 
        t.language.code.toLowerCase().startsWith('en') && !t.isAutoGenerated
    ).firstOrNull;
    
    if (track != null) {
      _logger.d('Found manual English track: ${track.language.code}');
      return track;
    }

    // Try auto-generated English
    track = tracks.where((t) =>
        t.language.code.toLowerCase().startsWith('en') && t.isAutoGenerated
    ).firstOrNull;
    
    if (track != null) {
      _logger.d('Found auto-generated English track: ${track.language.code}');
      return track;
    }

    // Try any manual track
    track = tracks.where((t) => !t.isAutoGenerated).firstOrNull;
    
    if (track != null) {
      _logger.d('Found manual non-English track: ${track.language.code}');
      return track;
    }

    // Fall back to first available
    _logger.d('Falling back to first available track: ${tracks.first.language.code}');
    return tracks.first;
  }

  /// Convert YouTube captions to app subtitle format
  List<Subtitle> _convertToSubtitles(List<ClosedCaption> captions) {
    return captions.map((caption) => Subtitle(
      startTime: caption.offset.inMilliseconds,
      endTime: (caption.offset + caption.duration).inMilliseconds,
      text: _cleanSubtitleText(caption.text),
    )).toList();
  }

  /// Clean subtitle text (remove extra formatting, normalize)
  String _cleanSubtitleText(String text) {
    return text
        .replaceAll(RegExp(r'<[^>]*>'), '') // Remove HTML tags
        .replaceAll(RegExp(r'\s+'), ' ')    // Normalize whitespace
        .trim();
  }

  /// Fallback method to fetch auto-generated transcript
  Future<List<Subtitle>> _fetchAutoGeneratedTranscript(String videoId) async {
    try {
      _logger.i('Attempting to fetch auto-generated transcript for $videoId');
      
      // Get the video metadata first
      final video = await _getVideoWithCache(videoId);
      
      // Try to get closed captions again with different parameters
      final manifest = await _youtubeExplode.videos.closedCaptions
          .getManifest(videoId)
          .timeout(const Duration(seconds: 30));

      if (manifest.tracks.isEmpty) {
        _logger.w('No tracks available for auto-generated transcript');
        return [];
      }

      // Specifically look for auto-generated tracks
      final autoTracks = manifest.tracks.where((t) => t.isAutoGenerated).toList();
      if (autoTracks.isEmpty) {
        _logger.w('No auto-generated tracks found');
        return [];
      }

      _logger.i('Found ${autoTracks.length} auto-generated tracks');

      // Try each auto-generated track
      for (var track in autoTracks) {
        try {
          _logger.i('Trying auto-generated track: ${track.language.code}');
          
          final closedCaptions = await _youtubeExplode.videos.closedCaptions
              .get(track)
              .timeout(const Duration(seconds: 60));

          if (closedCaptions.captions.isNotEmpty) {
            _logger.i('Successfully fetched ${closedCaptions.captions.length} auto-generated captions');
            _subtitleCache[videoId] = closedCaptions.captions;
            return _convertToSubtitles(closedCaptions.captions);
          }
        } catch (e) {
          _logger.w('Auto-generated track ${track.language.code} failed: $e');
          continue;
        }
      }

      return [];
    } catch (e) {
      _logger.e('Error in _fetchAutoGeneratedTranscript', e);
      return [];
    }
  }

  /// Alternative fallback method to fetch subtitles with direct URL approach
  Future<List<Subtitle>> _fetchSubtitlesFallback(String videoId) async {
    try {
      _logger.i('Attempting fallback subtitle fetch for $videoId');
      
      // Try multiple approaches
      final approaches = [
        () => _fetchWithFreshClient(videoId),
        () => _fetchWithRawUrlApproach(videoId),
      ];
      
      for (var approach in approaches) {
        try {
          final result = await approach();
          if (result.isNotEmpty) {
            _logger.i('Fallback approach succeeded with ${result.length} subtitles');
            return result;
          }
        } catch (e) {
          _logger.w('Fallback approach failed: $e');
          continue;
        }
      }

      return [];
    } catch (e) {
      _logger.e('Error in _fetchSubtitlesFallback', e);
      return [];
    }
  }

  /// Try with a fresh YouTube client
  Future<List<Subtitle>> _fetchWithFreshClient(String videoId) async {
    // Reinitialize YouTube client to clear any cached state
    final freshYoutube = YoutubeExplode();
    
    try {
      // Try with fresh client
      final manifest = await freshYoutube.videos.closedCaptions
          .getManifest(videoId)
          .timeout(const Duration(seconds: 45));

      if (manifest.tracks.isNotEmpty) {
        _logger.i('Fresh client found ${manifest.tracks.length} tracks');

        // Try all tracks systematically
        for (var track in manifest.tracks) {
          try {
            _logger.i('Fresh client trying track: ${track.language.code}');
            
            final closedCaptions = await freshYoutube.videos.closedCaptions
                .get(track)
                .timeout(const Duration(seconds: 60));

            if (closedCaptions.captions.isNotEmpty) {
              _logger.i('Fresh client success: ${closedCaptions.captions.length} captions from ${track.language.code}');
              _subtitleCache[videoId] = closedCaptions.captions;
              return _convertToSubtitles(closedCaptions.captions);
            }
          } catch (e) {
            _logger.w('Fresh client track ${track.language.code} failed: $e');
            continue;
          }
        }
      }
      return [];
    } finally {
      freshYoutube.close();
    }
  }

  /// Try a raw URL-based approach with custom XML parsing
  Future<List<Subtitle>> _fetchWithRawUrlApproach(String videoId) async {
    try {
      _logger.i('Trying raw URL approach for $videoId');
      
      // Get the manifest to get track URLs
      final manifest = await _youtubeExplode.videos.closedCaptions
          .getManifest(videoId)
          .timeout(const Duration(seconds: 30));

      if (manifest.tracks.isEmpty) {
        return [];
      }

      // Try to get the raw subtitle URL and fetch it directly
      for (var track in manifest.tracks.where((t) => t.language.code.toLowerCase().startsWith('en'))) {
        try {
          _logger.i('Trying raw URL for track: ${track.language.code}');
          
          // Get the track URL
          final trackUrl = track.url.toString();
          _logger.d('Track URL: $trackUrl');

          // Try to download the subtitle content directly
          final response = await http.get(Uri.parse(trackUrl))
              .timeout(const Duration(seconds: 60));

          if (response.statusCode == 200) {
            final content = response.body;
            _logger.i('Downloaded raw subtitle content: ${content.length} characters');
            
            // Try to parse the XML content with better error handling
            final subtitles = await _parseSubtitleContent(content, track.language.code);
            if (subtitles.isNotEmpty) {
              _logger.i('Raw URL parsing success: ${subtitles.length} subtitles');
              return subtitles;
            }
          }
        } catch (e) {
          _logger.w('Raw URL approach failed for track ${track.language.code}: $e');
          continue;
        }
      }

      return [];
    } catch (e) {
      _logger.e('Error in raw URL approach', e);
      return [];
    }
  }

  /// Parse subtitle content with robust error handling
  Future<List<Subtitle>> _parseSubtitleContent(String content, String languageCode) async {
    try {
      // First, try to clean up the content
      String cleanContent = content.trim();
      
      // Log the first part of the content to see what we're dealing with
      _logger.d('Content preview: ${cleanContent.substring(0, math.min(200, cleanContent.length))}');

      // Try multiple parsing approaches
      final parsers = [
        () => _parseAsXml(cleanContent),
        () => _parseAsWebVTT(cleanContent),
        () => _parseAsSRT(cleanContent),
      ];

      for (var parser in parsers) {
        try {
          final result = await parser();
          if (result.isNotEmpty) {
            _logger.i('Successfully parsed ${result.length} subtitles using a parser');
            return result;
          }
        } catch (e) {
          _logger.d('Parser failed: $e');
          continue;
        }
      }

      return [];
    } catch (e) {
      _logger.e('Error parsing subtitle content', e);
      return [];
    }
  }

  /// Try to parse as XML
  Future<List<Subtitle>> _parseAsXml(String content) async {
    // This is where the original XML parsing was failing
    // We can add more robust XML parsing here
    final subtitles = <Subtitle>[];
    
    // Simple regex-based parsing as fallback
    final RegExp timeRegex = RegExp(r't="(\d+)".*?t="(\d+)".*?>([^<]+)');
    final matches = timeRegex.allMatches(content);
    
    for (var match in matches) {
      try {
        final startTime = int.parse(match.group(1)!);
        final endTime = int.parse(match.group(2)!);
        final text = match.group(3)!.trim();
        
        if (text.isNotEmpty) {
          subtitles.add(Subtitle(
            startTime: startTime,
            endTime: endTime,
            text: _cleanSubtitleText(text),
          ));
        }
      } catch (e) {
        continue; // Skip malformed entries
      }
    }
    
    return subtitles;
  }

  /// Try to parse as WebVTT
  Future<List<Subtitle>> _parseAsWebVTT(String content) async {
    final subtitles = <Subtitle>[];
    
    if (!content.contains('WEBVTT')) {
      return subtitles; // Not WebVTT format
    }
    
    final lines = content.split('\n');
    for (int i = 0; i < lines.length; i++) {
      final line = lines[i].trim();
      
      // Look for time patterns like "00:00:01.000 --> 00:00:05.000"
      if (line.contains('-->')) {
        try {
          final parts = line.split('-->');
          if (parts.length == 2) {
            final startTime = _parseTimeStamp(parts[0].trim());
            final endTime = _parseTimeStamp(parts[1].trim());
            
            // Get the text from the next line(s)
            String text = '';
            for (int j = i + 1; j < lines.length && lines[j].trim().isNotEmpty; j++) {
              if (lines[j].contains('-->')) break;
              text += lines[j].trim() + ' ';
            }
            
            if (text.isNotEmpty) {
              subtitles.add(Subtitle(
                startTime: startTime,
                endTime: endTime,
                text: _cleanSubtitleText(text),
              ));
            }
          }
        } catch (e) {
          continue; // Skip malformed entries
        }
      }
    }
    
    return subtitles;
  }

  /// Try to parse as SRT
  Future<List<Subtitle>> _parseAsSRT(String content) async {
    final subtitles = <Subtitle>[];
    
    final blocks = content.split('\n\n');
    for (var block in blocks) {
      final lines = block.trim().split('\n');
      if (lines.length >= 3) {
        try {
          // Second line should be the timing
          final timeLine = lines[1];
          if (timeLine.contains('-->')) {
            final parts = timeLine.split('-->');
            if (parts.length == 2) {
              final startTime = _parseTimeStamp(parts[0].trim());
              final endTime = _parseTimeStamp(parts[1].trim());
              
              // Remaining lines are the text
              final text = lines.skip(2).join(' ').trim();
              
              if (text.isNotEmpty) {
                subtitles.add(Subtitle(
                  startTime: startTime,
                  endTime: endTime,
                  text: _cleanSubtitleText(text),
                ));
              }
            }
          }
        } catch (e) {
          continue; // Skip malformed entries
        }
      }
    }
    
    return subtitles;
  }

  /// Parse timestamp to milliseconds
  int _parseTimeStamp(String timestamp) {
    // Handle formats like "00:00:01.000" or "00:00:01,000"
    timestamp = timestamp.replaceAll(',', '.');
    final parts = timestamp.split(':');
    
    if (parts.length >= 3) {
      final hours = int.parse(parts[0]);
      final minutes = int.parse(parts[1]);
      final secondsParts = parts[2].split('.');
      final seconds = int.parse(secondsParts[0]);
      final milliseconds = secondsParts.length > 1 
          ? int.parse(secondsParts[1].padRight(3, '0').substring(0, 3))
          : 0;
      
      return (hours * 3600 + minutes * 60 + seconds) * 1000 + milliseconds;
    }
    
    return 0;
  }

  /// Get video quality options
  Future<List<VideoStreamInfo>> getVideoStreams(String videoId) async {
    try {
      final manifest = await _youtubeExplode.videos.streamsClient.getManifest(videoId);
      return manifest.videoOnly.toList();
    } catch (e) {
      _logger.e('Error fetching video streams', e);
      return [];
    }
  }

  /// Check if video is available without full processing
  Future<bool> isVideoAvailable(String url) async {
    try {
      final videoId = YoutubeUtils.extractYoutubeVideoId(url);
      if (videoId == null) return false;
      
      final video = await _youtubeExplode.videos.get(videoId).timeout(
        const Duration(seconds: 10)
      );
      
      return video.duration != null; // Simple availability check
    } catch (e) {
      return false;
    }
  }

  /// Get channel information
  Future<Channel?> getChannelInfo(String channelId) async {
    try {
      return await _youtubeExplode.channels.get(channelId);
    } catch (e) {
      _logger.e('Error fetching channel info', e);
      return null;
    }
  }

  /// Clear all caches
  void clearCache() {
    _videoCache.clear();
    _subtitleCache.clear();
    _logger.i('Cleared YouTube service caches');
  }

  /// Clear old cache entries (call periodically)
  void cleanupCache({int maxEntries = 50}) {
    if (_videoCache.length > maxEntries) {
      final entries = _videoCache.entries.toList();
      _videoCache.clear();
      // Keep only the most recent entries
      _videoCache.addEntries(entries.take(maxEntries));
    }
    
    if (_subtitleCache.length > maxEntries) {
      final entries = _subtitleCache.entries.toList();
      _subtitleCache.clear();
      _subtitleCache.addEntries(entries.take(maxEntries));
    }
    
    _logger.i('Cleaned up YouTube service caches');
  }

  /// Generate unique ID
  String _generateId() {
    return const Uuid().v4();
  }

  /// Dispose resources
  void dispose() {
    _youtubeExplode.close();
    _videoCache.clear();
    _subtitleCache.clear();
    _logger.d('YouTube service disposed');
  }
}

/// Custom exception for YouTube service errors
class YouTubeServiceException implements Exception {
  final String message;
  
  const YouTubeServiceException(this.message);
  
  @override
  String toString() => 'YouTubeServiceException: $message';
}

/// Custom exception for subtitle-specific errors that are not critical to video playback.
class YouTubeSubtitleException implements Exception {
  final String message;

  const YouTubeSubtitleException(this.message);

  @override
  String toString() => 'YouTubeSubtitleException: $message';
}
/// Extension to add firstOrNull method
extension IterableExtension<T> on Iterable<T> {
  T? get firstOrNull {
    final iterator = this.iterator;
    if (iterator.moveNext()) {
      return iterator.current;
    }
    return null;
  }
}
